title: 排队理论及Little's Law
date: 2014-07-26 18:44:12
updated: 2014-07-26 18:44:12
tags:
 - 异步
 - 并发
 - queueing threory
 - 排队理论
 - little's law
 - 利特尔法则
 - 泊松过程
 - 马尔科夫链
 - 负指数分布
categories:

---

![](http://img01.e23.cn/2012/0729/20120729064952752.jpg)

## 队列无处不在

　　最近一直在做异步编程框架方面的工作。异步化最重要的几个概念是，消息/事件、队列/缓冲区、线程池等，在实际应用中需要考虑到队列满等问题。其实队列无处不在，不止是在异步程序框架里。诶，等一等，同步程序哪来的队列？的确是没有“明显的”。如果你用线程池执行同步代码，你得有有锁或信号量或等待队列从池里取出线程。如果你很彪悍，每个请求都新建一个线程来处理，那当你的线程数超过CPU数时，线程得在队列里等OS调度，还徒增线程上下文切换和条件变量的开销。队列无处不在，拥抱队列吧！既然无法避免队列，就用心设计好队列，比如用上无锁队列。

　　现实生活中队列也是无处不在，比如宇宙中心五道口的枣糕王队列和最近刚出来的西少爷队列，五彩城的外婆家队列，小米的周二抢手机队列，每个小米员工身上都挂着一堆F码队列，北京车牌摇号是个巨大的队列，等等……

## 什么是队列，什么是排队理论

　　*queue*一词来自于拉丁语*cauda*，是“马尾巴”的意思。排队理论（Queueing theory）是研究排队（queues，或者waiting lines）的数学方法。拼写成 "queueing" 而不是"queuing"据说是因为学术界相关领域有个很牛叉的期刊叫“Queueing Systems”……

　　一个在丹麦哥本哈根电话交换局工作的工程师 Agner Krarup Erlang（哈哈，就是Erlang编程语言的出处之一，另一出处是*Er*icsson *Lang*uage），研究人们打电话的方式，发展出人们需要等待多久的公式，并于1909年出版了关于排队理论的第一篇论文，当时称为话务理论。他在热力学统计平衡理论的启发下，成功地建立了电话统计平衡模型，并由此得到一组递推状态方程，从而导出Erlang电话损失率公式。自20世纪初以来，电话系统的设计一直在应用这个公式。30年代苏联数学家А.Я.欣钦把处于统计平衡的电话呼叫流称为最简单流。瑞典数学家巴尔姆又引入有限后效流等概念和定义。他们用数学方法深入地分析了电话呼叫的本征特性，促进了排队论的研究。50年代初，美国数学家关于生灭过程的研究、英国数学家D.G.肯德尔提出嵌入马尔可夫链理论，以及对排队队型的分类方法，为排队论奠定了理论基础。在这以后，L.塔卡奇等人又将组合方法引进排队论，使它更能适应各种类型的排队问题。70年代以来，人们开始研究排队网络和复杂排队问题的渐近解等，成为研究现代排队论的新趋势。

## 队列的形成
　　队列的形成是由于服务对象到达时间快于服务时间导致的。看这两种极端情况：
* 服务时间为1秒/个，到达时间为2秒/个，永远不会产生队列堆积
* 服务时间为2秒/个，到达时间为1秒/个，队列会永无止境的增加

　　而在现实服务系统中，服务时间和到达时间都是不是恒定的。如果一个队列不会随时间增加而无限增长，那么可以说它是*稳定*的。而对于单服务节点队列来说，如果其*平均服务时间*小于*平均到达时间*（或*平均服务速率*大于*平均到达速率*），则可以说它是稳定的。

　　例如下图，横坐标为时间，纵坐标为队列长度，这是一个稳定的队列，我们能看到“忙”与“闲”的交替，
```
　|
队|                                   __
列|        __                      __|  |__
长|     __|  |__          __    __|        |
度|  __|        |__    __|  |__|           |____
　|_|______________|__|_________________________|______
　　　　时间
```
　　而下图则是一个不稳定的队列，就像在高速路上发生车祸后的结果一样：
```
　|                          ____| 
　|                       __|        
　|                    __|            
队|                 __|               
列|        __    __|               
长|     __|  |__|
度|  __|        
　|_|__________________________________________________
　　　　时间
```
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

## 基本模型
　　排队系统又称服务系统。服务系统由服务系统和服务对象（顾客）构成。服务对象到来的时刻和对他服务的时间（即占用服务系统的时间）都是随机的。最简单的排队系统模型包括三个组成部分：输入过程、排队策略和服务系统。

### 输入过程
　　输入过程考察的是顾客到达服务系统的规律。它可以用一定时间内顾客到达数或前后两个顾客相继到达的间隔时间来描述，一般分为确定型和随机型两种。例如，在生产线上加工的零件按规定的间隔时间依次到达加工地点，定期运行的班车、班机等都属于确定型输入。随机型的输入是指在时间 $t$ 内顾客到达数 $n(t)$ 服从一定的随机分布。如服从泊松分布，则在时间 $t$ 内到达$n$个顾客的概率为 
$$ 
P_n(t)=\frac{e^{-\lambda t}{(\lambda t)}^n}{n!} (n=0,1,2,...,N)
$$
　　或相继到达的顾客的间隔时间 $T$ 服从负指数分布，即
$$
P(T \leqslant t)=1-e^{-\lambda t}
$$
　　式中 $\lambda$ 为单位时间顾客期望到达数，称为平均到达速率； $1/\lambda$ 为平均间隔时间。在排队论中，讨论的输入过程主要是随机型的。

### 排队策略
　　排队策略分为等待策略、丢弃策略和混合策略三种。当顾客到达时，所有服务系统都被占用，则顾客排队等候，即为等待策略。在等待策略中，为顾客进行服务的次序可以是先到先服务，或后到先服务，或是随机服务和有优先权服务（如医院接待急救病人）。如果顾客来到后看到服务系统没有空闲立即离去，则为丢弃策略。有些系统因留给顾客排队等待的空间有限，因此超过所能容纳人数的顾客必须离开系统，这种排队策略就是混合策略。

### 服务系统
　　可以是一个或多个服务节点。多个服务节点可以是平行排列的，也可以是串连排列的。服务时间一般也分成确定型和随机型两种。例如，自动冲洗汽车的装置对每辆汽车冲洗（服务）时间是相同的，因而是确定型的。而随机型服务时间 $v$ 则服从一定的随机分布。如果服从负指数分布，则其分布函数是
$$
P(v \leqslant t) = 1 - e^{-\mu t}    (t \geqslant 0)
$$
　　式中 $\mu$ 为平均服务率， $1/\mu$ 为平均服务时间。

### 表示法

　　一般使用David G. Kendall表示法，A/S/C：
* A（Arrival Process）：描述顾客到达系统的概率密度分布（在消息系统中对应于消息到达的概率分布）
* S（Service Process）：描述顾客服务耗时的概率密度分布（在消息系统对应于消息处理的时间分布）
* C（Number of Servers）：描述系统中的服务节点个数

　　其中，A、S可以是以下任意一个：
* M (Markov)：Exponential probability density
* D (Deterministic)：All customers have the same value
* G (General)：Any arbitrary probability distribution

## 示例排队系统

　　例如有以下类型的排队系统：

### M/M/1

* 最简单的排队系统，一个服务节点
* 到达时间负指数分布（泊松过程）
* 服务时间负指数分布（泊松过程）
* 服务策略：FIFS（先入队先服务）

#### 泊松过程（Poisson process）

　　泊松过程以法国数学家泊松命名，是随机过程的一种。M/M/1系统假设到达时间符合泊松分布，在现实系统中需要满足以下三点才可以做此近似假设：
* 无限请求数，或请求数量很大
* 单次请求对系统性能和资源占用都很小
* 所有请求之间相互独立，互不影响/依赖
　　例如公路系统中的车辆，就满足：
* 车辆数非常多
* 每辆车占用公路上的位置很小
* 所有的车决定走哪条路、怎么走，对其他车辆影响不大
　　如果公路上正在举行公路赛，那么条件2、3就不满足了，就不能用泊松过程近似。

　　$n$个请求在时间$0$ ~ $t$内到达的泊松过程的概率密度分布可以表示如下：
$$
P_n(t)=\frac{(\lambda t)^n}{n!}e^{-\lambda t}
$$
　　其中，
* $t$是历经时间
* $n$是这段时间请求到达总数
* $\lambda$是平均到达速率

#### 负指数分布
　　如果泊松概率分布不够直观，可以将其简化：在一段时间内没有任何请求到达的分布，也就是泊松分布中的$n=0$：
$$
P_0(t)=e^{-\lambda t}
$$
　　还拿高速公路举例子，一段路上平均每10s有1个车到达（到达速率为0.1 车/秒）。下图是随时间t没有一个车到达的概率分布。
![](http://www.eventhelix.com/realtimemantra/congestioncontrol/images/poisson.gif)
　　可见，一段时间内看不到一辆车的概率会碎观察时间间隔的增长而急剧下降：１秒内是90%，20秒内只有10%了。

#### M/M/1系统的结果分析
　　对于稳定的系统，服务速率要大于到达速率。定义“流量强度”$\rho$如下：
$$
\rho = \lambda / \mu
$$
　　其中$\lambda$为到达速率，$\mu$为服务速率。也就是稳定系统的$rho<1$。则系统中的平均请求数$N$为：
$$
N = \frac{\rho}{1-\rho}
$$
　　容易看出，当$rho$趋近于1时$N$急速增大。从这个式子可以简单推导出总的等待时间（包括服务时间）（见后文Little's Law）：
$$
T = \frac{1}{\mu - \lambda}
$$

### M/D/1，M/D/n系统

Agner Krarup Erlang在1917建模并解决了M/D/1系统，随后在1920年建模了M/D/n系统：
* M stands for Markov or memoryless and means arrivals occur according to a Poisson process
* D stands for deterministic and means jobs arriving at the queue require a fixed amount of service
* n describes the number of servers at the queueing node (k = 1, 2,...).

### M/G/1， M/G/n系统
M/G/1系统由Felix Pollaczek在1930年解决。而M/G/n系统的性能分析仍然是一个[开放问题](http://en.wikipedia.org/wiki/M/G/k_queue)。

### G/G/n系统
This is the most general queueing system where the arrival and service time processes are both arbitrary. The system has n servers. No analytical solution is known for this queueing system.


## 测量指标
* 平均等待时间、等待时间.99/.95/.75
* 服务节点利用率
  * 比如，消息到达速率为10ms一个，平均每个处理时间为8ms，则服务节点可用率为 $P=(1 / 10) * 8 = 80% $
* 吞吐/QPS
* 平均等待消息个数
* 消息等待个数分布（例如 $P(n), n=0, 1, 2...$表示有n个消息在等待的概率）

## Little's Law
　　一般译为利特尔法则，指在一个稳定的系统（排队理论中的系统）中，长时间观察到的平均顾客数量$L$，等于长时间观察到的有效到达速率$\lambda$与平均每个顾客在系统中花费的时间之乘积，即
$$
L = \lambda W
$$
　　由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授John Little于1961年所提出与证明。这一法则为精益生产的改善方向指明了道路。如何有效地缩短生产周期呢？利特尔法则已经很明显地指出了方向。一个方向是提高产能，从而降低生产节拍；另一个方向就是压缩存货数量。然而，提高往往意味着增加很大的投入。另外，生产能力的提升虽然可以缩短生产周期，但是，生产能力的提升总有个限度，我们无法容忍生产能力远远超过市场的需求。一般来说，每个公司在一定时期内的生产能力是大致不变的，而从长期来看，各公司也会力图使自己公司的产能与市场需求相吻合。因此，最有效地缩短生产周期的方法就是压缩在制品数量。
　　利特尔法则不仅适用于整个系统，而且也适用于系统的任何一部分。

　　平均顾客数量$L=\lambda/(\mu-\lambda)$，则平均等待时间（排队时间+服务时间）可以计算为：
$$
W=1/(\mu - \lambda)
$$
　　平均等待时间为：
$$
W_q = 1 /(\mu − \lambda) − 1/\mu = \lambda /\mu( \mu − \lambda)
$$

## 有什么用？
　　可以根据Little's Law设计系统中的队列长度——压缩在制品数量，比如Mampa的mailbox长度设计。
